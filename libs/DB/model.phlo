@ version:     1.1
@ creator:     q-ai.nl
@ description: Phlo ORM class (unified columns/schema)

@ type:        abstract class
@ requires:    @DB @MySQL apcu?

static DB => %MySQL
static objRecords = []
static objLoaded = []
static objCache = false

static canView = true
static canCreate = true
static canChange = true
static canDelete = true

static columns() => isset(static::$columns) ? static::$columns : (method_exists(static::class, 'schema') ? static::_columns() : '*')
static _columns(){
	$fq = static::DB()->fieldQuotes
	$list = array_merge(...array_values(array_filter(loop(static::fields(), fn($field, $column) => in_array($field->type, ['child', 'many', 'virtual']) ? null : ($field->columns ?: [static::$table."$fq.$fq".$column])))))
	return $fq.implode("$fq,$fq", $list).$fq
}
static fields() => method_exists(static::class, 'schema') ? static::_fields() : (static::$fields ?? [])
static _fields() => loop(static::schema(), fn($field, $column) => last($field->name ??= $column, $field->type === 'parent' && $field->obj ??= $column, $field))
static field($name) => static::fields()[$name]

static create(...$args) => static::record(id: static::createRecord(...$args))
static createRecord(...$args) => static::DB()->create(static::$table, ...$args)
static change($where, ...$args) => static::DB()->change(static::$table, $where, ...$args)
static delete($where, ...$args) => static::DB()->delete(static::$table, $where, ...$args)

method objSave {
	$this->id || error('Can\'t save '.static::class.' record without an id')
	if (static::item(id: $this->id, columns: 'id')){
		static::change('id=?', $this->id, ...$this)
		return static::record(id: $this->id)
	}
	else return static::create(...$this)
}

static column(...$args) => static::recordsLoad($args, 'fetchAll', [PDO::FETCH_COLUMN])
static item(...$args) => static::recordsLoad($args, 'fetch', [PDO::FETCH_COLUMN])
static pair(...$args) => static::recordsLoad($args, 'fetchAll', [PDO::FETCH_KEY_PAIR])
static records(...$args) => static::recordsLoad($args, 'fetchAll', [PDO::FETCH_CLASS|PDO::FETCH_UNIQUE, static::class], true)
static recordCount(...$args) => static::item(...$args, columns: 'COUNT(id)')
static record(...$args) => count($records = static::records(...$args)) > 1 ? error('Multiple records for '.static::class) : (current($records) ?: null)

static recordsLoad($args, $fetch, $fetchMode, $saveRelations = false){
	$args['table'] ??= static::$table
	$saveRelations && $args['columns'] ??= static::$table.'.id as _,'.static::columns()
	isset(static::$joins) && $args['joins'] = static::$joins.(isset($args['joins']) ? " $args[joins]" : void)
	method_exists(static::class, 'where') && $args['where'] = static::where().(isset($args['where']) ? " AND $args[where]" : void)
	isset(static::$group) && $args['group'] ??= static::$group
	isset(static::$order) && $args['order'] ??= static::$order
	if ($cacheKey = $args['cacheKey'] ?? null) unset($args['cacheKey'])
	if ($duration = $args['cache'] ?? static::objCache()){
		unset($args['cache'])
		$records = apcu($cacheKey ?? static::class.slash.md5(json_encode($args)), fn() => static::DB()->load(...$args)->$fetch(...$fetchMode), $duration === true ? 86400 : $duration)
	}
	else $records = static::DB()->load(...$args)->$fetch(...$fetchMode)
	if ($saveRelations && $records) self::$objRecords[static::class] = (self::$objRecords[static::class] ?? []) + array_column($records, null, 'id')
	return $records
}

static objRel($key) => static::$classProps[static::class][$key] ??= method_exists(static::class, $key) ? static::$key() : static::$$key ?? []

prop objState = ['parents' => [], 'children' => [], 'many' => []]
method objGet($key) => $this->getParent($key) ?? $this->getChildren($key) ?? $this->getMany($key)
method objIn($ids) => $ids ? dq.implode(dq.comma.dq, $ids).dq : 'NULL'

method getParent($key){
	if (array_key_exists($key, $this->objState['parents'])) return $this->objState['parents'][$key]
	$parents = self::objRel('objParents')
	if (!$relation = $parents[$key] ?? null) return
	$isArray = is_array($relation)
	$class = $isArray ? $relation['obj'] : $relation
	$column = $isArray ? $relation['key'] ?? $key : $key
	if (!$parentId = $this->objData[$column] ?? null) return $this->objState['parents'][$key] = null
	if (!isset(self::$objRecords[$class][$parentId])){
		$idsToLoad = [$parentId => true]
		$allObjData = array_map(fn($record) => $record->objData, self::$objRecords[static::class] ?? [])
		foreach ($parents as $pKey => $pRelation){
			$pIsArray = is_array($pRelation)
			$pClass = $pIsArray ? $pRelation['obj'] : $pRelation
			if ($pClass === $class) foreach (array_column($allObjData, $pIsArray ? $pRelation['key'] ?? $pKey : $pKey) as $pId) $pId && !isset(self::$objRecords[$class][$pId]) && $idsToLoad[$pId] = true
		}
		if ($idsToLoad = array_keys($idsToLoad)) $class::records(where: 'id IN ('.$this->objIn($idsToLoad).')')
	}
	$parentObject = self::$objRecords[$class][$parentId] ?? null
	return $this->objState['parents'][$key] = $parentObject
}

method getChildren($key){
	if (array_key_exists($key, $this->objState['children'])) return $this->objState['children'][$key]
	if (!$relation = self::objRel('objChildren')[$key] ?? null) return
	$isArray = is_array($relation)
	$class = $isArray ? $relation['obj'] : $relation
	$column = $isArray ? $relation['key'] : static::class
	if (!isset(self::$objLoaded[static::class]['children'][$key])){
		$parentIds = array_keys(self::$objRecords[static::class] ?? [])
		if ($parentIds){
			$children = $class::records(where: '`'.$column.'` IN ('.$this->objIn($parentIds).')')
			foreach (self::$objRecords[static::class] AS $parentRecord) $parentRecord->objState['children'][$key] = []
			foreach ($children AS $childId => $child) !is_null($pId = $child->objData[$column] ?? null) && isset(self::$objRecords[static::class][$pId]) && self::$objRecords[static::class][$pId]->objState['children'][$key][$childId] = $child
		}
		self::$objLoaded[static::class]['children'][$key] = true
	}
	return $this->objState['children'][$key] ?? []
}

method getMany($key){
	if (array_key_exists($key, $this->objState['many'])) return $this->objState['many'][$key]
	if (!$relation = self::objRel('objMany')[$key] ?? null) return
	$class = $relation['obj']
	if (!isset(self::$objLoaded[static::class]['many'][$key])){
		$parentIds = array_keys(self::$objRecords[static::class] ?? [])
		if ($parentIds){
			$targetTable = $class::$table
			$records = $class::recordsLoad(arr(table: $relation['table'], columns: "`$targetTable`.*, `$relation[table]`.`$relation[localKey]` as _local_key", joins: "INNER JOIN `$targetTable` ON `$relation[table]`.`$relation[foreignKey]` = `$targetTable`.`id`", where: "`$relation[table]`.`$relation[localKey]` IN (".$this->objIn($parentIds).")"), 'fetchAll', [PDO::FETCH_CLASS, $class])
			foreach (self::$objRecords[static::class] AS $parentRecord) $parentRecord->objState['many'][$key] = []
			foreach ($records AS $record){
				$recordId = $record->id
				$parentId = $record->_local_key
				unset($record->_local_key)
				if (isset(self::$objRecords[static::class][$parentId])) self::$objRecords[static::class][$parentId]->objState['many'][$key][$recordId] = $record
			}
		}
		self::$objLoaded[static::class]['many'][$key] = true
	}
	return $this->objState['many'][$key] ?? []
}

method getCount($key){
	if (array_key_exists($key, $this->objState['counts'] ?? [])) return $this->objState['counts'][$key]
	if ($relation = self::objRel('objChildren')[$key] ?? null){
		if (!isset(self::$objLoaded[static::class]['children_count'][$key])){
			$parentIds = array_keys(self::$objRecords[static::class] ?? [])
			if ($parentIds){
				$isArray = is_array($relation)
				$class = $isArray ? $relation['obj'] : $relation
				$column = $isArray ? $relation['key'] : static::class
				$counts = $class::pair(columns: "`$column`, COUNT(*)", where: '`'.$column.'` IN ('.$this->objIn($parentIds).')', group: "`$column`")
				foreach (self::$objRecords[static::class] as $id => $record) $record->objState['counts'][$key] = (int)($counts[$id] ?? 0)
			}
			self::$objLoaded[static::class]['children_count'][$key] = true
		}
		return $this->objState['counts'][$key] ?? 0
	}
	if ($relation = self::objRel('objMany')[$key] ?? null){
		if (!isset(self::$objLoaded[static::class]['many_count'][$key])){
			$parentIds = array_keys(self::$objRecords[static::class] ?? [])
			if ($parentIds){
				$counts = static::DB()->load(table: $relation['table'], columns: "`$relation[localKey]`,COUNT(*)", where: '`'.$relation['localKey'].'` IN ('.$this->objIn($parentIds).')', group: "`$relation[localKey]`")->fetchAll(PDO::FETCH_KEY_PAIR)
				foreach (self::$objRecords[static::class] as $id => $record) $record->objState['counts'][$key] = (int)($counts[$id] ?? 0)
			}
			self::$objLoaded[static::class]['many_count'][$key] = true
		}
		return $this->objState['counts'][$key] ?? 0
	}
	return 0
}

method getLast($key){
	if (array_key_exists($key, $this->objState['last_child'] ?? [])) return $this->objState['last_child'][$key]
	if ($relation = self::objRel('objChildren')[$key] ?? null){
		if (!isset(self::$objLoaded[static::class]['last_child'][$key])){
			if ($parentIds = array_keys(self::$objRecords[static::class] ?? [])){
				$isArray = is_array($relation)
				$class = $isArray ? $relation['obj'] : $relation
				$column = $isArray ? $relation['key'] : static::class
				$childTable = $class::$table
				$whereClause = "`$column` IN (".$this->objIn($parentIds).") AND `$childTable`.`id` = (SELECT `id` FROM `$childTable` AS lc WHERE lc.`$column`=`$childTable`.`$column` ORDER BY `id` DESC LIMIT 1)"
				$lastChildren = $class::records(where: $whereClause)
				foreach (self::$objRecords[static::class] as $record) $record->objState['last_child'][$key] = null
				foreach ($lastChildren as $child) if (isset(self::$objRecords[static::class][$parentId = $child->objData[$column]])) self::$objRecords[static::class][$parentId]->objState['last_child'][$key] = $child
			}
			self::$objLoaded[static::class]['last_child'][$key] = true
		}
		return $this->objState['last_child'][$key] ?? null
	}
	return null
}

static objParents(){
	if (property_exists(static::class, 'objParents')) return static::$objParents
	if (!method_exists(static::class, 'schema')) return []
	return loop(array_filter(static::fields(), fn($f) => $f->type === 'parent'), fn($f, $c) => $f->key ? arr(obj: $f->obj, key: $f->key) : ($f->obj ?? $c))
}

static objChildren(){
	if (property_exists(static::class, 'objChildren')) return static::$objChildren
	if (!method_exists(static::class, 'schema')) return []
	return loop(array_filter(static::fields(), fn($f) => $f->type === 'child'), fn($f, $c) => $f->key ? arr(obj: $f->obj, key: $f->key) : ($f->obj ?? $c))
}

static objMany(){
	if (property_exists(static::class, 'objMany')) return static::$objMany
	if (!method_exists(static::class, 'schema')) return []
	return loop(array_filter(static::fields(), fn($f) => $f->type === 'many'), fn($f) => arr(obj: $f->obj, table: $f->table, localKey: $f->localKey ?? static::class, foreignKey: $f->foreignKey ?? $f->obj))
}

static createTable(){
	method_exists(static::class, 'schema') || error(static::class.' has no schema()')
	return 'CREATE TABLE `'.static::$table.'` ('.lf.tab.implode(",\n\t", array_merge(...array_values(array_filter(loop(static::fields(), fn($field) => loop((array)$field->sql, fn($sql) => $sql.($field->required || $field->nullable === false ? ' NOT' : void).' NULL')))))).",\n\tPRIMARY KEY (`id`)\n)"
}
